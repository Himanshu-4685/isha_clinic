const express = require('express');
const cors = require('cors');
const { google } = require('googleapis');
const path = require('path');
const fs = require('fs');

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('.'));

// Load Google Sheets credentials
const credentials = JSON.parse(fs.readFileSync('./credential.json'));

// Google Sheets configuration
const SPREADSHEET_ID = '1_TaZcx59rVbbAH1mIqQnkUCXXDnoZshDHd9PEFrpA5U';

// Initialize Google Sheets API
const auth = new google.auth.GoogleAuth({
    credentials: credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets']
});

const sheets = google.sheets({ version: 'v4', auth });

// Helper function to get next Tuesday or Friday
function getNextTestDate() {
    const today = new Date();
    const currentDay = today.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

    // Tuesday = 2, Friday = 5
    const tuesday = 2;
    const friday = 5;

    let daysToAdd = 0;

    if (currentDay < tuesday) {
        // If today is before Tuesday, next test is this Tuesday
        daysToAdd = tuesday - currentDay;
    } else if (currentDay < friday) {
        // If today is Tuesday, Wednesday, or Thursday, next test is this Friday
        daysToAdd = friday - currentDay;
    } else {
        // If today is Friday, Saturday, or Sunday, next test is next Tuesday
        daysToAdd = (7 - currentDay) + tuesday;
    }

    const nextTestDate = new Date(today);
    nextTestDate.setDate(today.getDate() + daysToAdd);

    return nextTestDate.toISOString().split('T')[0]; // Return YYYY-MM-DD format
}

// API Routes

// Test endpoint
app.get('/api/test', (req, res) => {
    res.json({ message: 'Google Sheets API server is running!', timestamp: new Date().toISOString() });
});

// Lookup patient by IYC number
app.get('/api/patient/:iycNumber', async (req, res) => {
    try {
        const { iycNumber } = req.params;

        console.log(`Looking up patient with IYC: ${iycNumber}`);

        // Read from Patient Database worksheet (including column G for category)
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Patient Database!A:G',
        });

        const rows = response.data.values || [];

        // Find matching IYC number (case-insensitive)
        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            if (row[1] && row[1].toString().toLowerCase() === iycNumber.toLowerCase()) {
                return res.json({
                    found: true,
                    name: row[0] || '',
                    iycNumber: row[1] || '',
                    phone: row[4] || '',
                    category: row[6] || '' // Column G for category
                });
            }
        }

        res.json({ found: false });

    } catch (error) {
        console.error('Error looking up patient:', error);
        res.status(500).json({
            error: 'Failed to lookup patient',
            details: error.message
        });
    }
});

// Save blood test
app.post('/api/blood-test', async (req, res) => {
    try {
        const { schedule, testDate, iycNumber, patientName, phoneNumber, testName, referredBy, remarks = '', category = '' } = req.body;

        console.log('Saving blood test:', req.body);

        // Use provided date or calculate next test date
        const finalDate = testDate || getNextTestDate();
        const timestamp = new Date().toISOString();

        // Prepare row data for Blood_Test_Data worksheet
        // Columns: A=ID, B=Date, C=IYC, D=Name, E=Category, F=Phone, G=Test, H=Referred By, I=Status, J=Remarks, K=Created, L=Updated
        const testId = `BT_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const values = [[testId, finalDate, iycNumber, patientName, category, phoneNumber, testName, referredBy, schedule, remarks, timestamp, timestamp]];

        // Check if Blood_Test_Data worksheet exists, create if not
        await ensureWorksheetExists('Blood_Test_Data');

        // Insert new row at the top (after header)
        await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: {
                requests: [{
                    insertDimension: {
                        range: {
                            sheetId: await getSheetId('Blood_Test_Data'),
                            dimension: 'ROWS',
                            startIndex: 1, // Insert after header row
                            endIndex: 2
                        },
                        inheritFromBefore: false
                    }
                }]
            }
        });

        // Add the data to the new row
        const range = 'Blood_Test_Data!A2:L2';
        await sheets.spreadsheets.values.update({
            spreadsheetId: SPREADSHEET_ID,
            range: range,
            valueInputOption: 'RAW',
            resource: {
                values: values
            }
        });

        res.json({
            success: true,
            message: 'Blood test saved successfully',
            data: {
                id: testId,
                status: schedule,
                values: values[0]
            }
        });

    } catch (error) {
        console.error('Error saving blood test:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to save blood test',
            error: error.message
        });
    }
});

// Helper function to get sheet ID by name
async function getSheetId(worksheetName) {
    try {
        const response = await sheets.spreadsheets.get({
            spreadsheetId: SPREADSHEET_ID
        });

        const sheet = response.data.sheets.find(s => s.properties.title === worksheetName);

        if (!sheet) {
            throw new Error(`Worksheet '${worksheetName}' not found`);
        }

        return sheet.properties.sheetId;
    } catch (error) {
        console.error('Error getting sheet ID:', error);
        throw error;
    }
}

// Helper function to ensure worksheet exists
async function ensureWorksheetExists(worksheetName) {
    try {
        // Try to get the sheet first
        await getSheetId(worksheetName);
        console.log(`Worksheet '${worksheetName}' already exists`);
    } catch (error) {
        if (error.message.includes('not found')) {
            console.log(`Creating worksheet '${worksheetName}'`);

            // Create the worksheet
            await sheets.spreadsheets.batchUpdate({
                spreadsheetId: SPREADSHEET_ID,
                resource: {
                    requests: [{
                        addSheet: {
                            properties: {
                                title: worksheetName
                            }
                        }
                    }]
                }
            });

            // Add headers if it's the Blood_Test_Data worksheet
            if (worksheetName === 'Blood_Test_Data') {
                const headers = [['ID', 'Date', 'IYC Number', 'Patient Name', 'Category', 'Phone', 'Test Name', 'Referred By', 'Status', 'Remarks', 'Created', 'Updated']];
                await sheets.spreadsheets.values.update({
                    spreadsheetId: SPREADSHEET_ID,
                    range: `${worksheetName}!A1:L1`,
                    valueInputOption: 'RAW',
                    resource: {
                        values: headers
                    }
                });
            }
        } else {
            throw error;
        }
    }
}

// Get tests by status
app.get('/api/blood-tests/:status', async (req, res) => {
    try {
        const { status } = req.params;

        console.log(`Getting tests with status: ${status}`);

        // Ensure the worksheet exists
        await ensureWorksheetExists('Blood_Test_Data');

        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Blood_Test_Data!A:L',
        });

        const rows = response.data.values || [];

        // Skip header row and filter by status
        const tests = rows.slice(1)
            .filter(row => row[8] === status) // Status is in column I (index 8)
            .map(row => ({
                id: row[0] || '',
                date: row[1] || '',
                iycNumber: row[2] || '',
                name: row[3] || '',
                category: row[4] || '',
                phone: row[5] || '',
                testName: row[6] || '',
                referredBy: row[7] || '',
                status: row[8] || '',
                remarks: row[9] || '',
                created: row[10] || '',
                updated: row[11] || ''
            }))
            .filter(test => test.id); // Only include rows with IDs

        res.json({
            success: true,
            status: status,
            tests: tests,
            count: tests.length
        });

    } catch (error) {
        console.error('Error getting tests:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get tests',
            error: error.message
        });
    }
});

// Update test status (bulk operation)
app.post('/api/blood-tests/bulk-update', async (req, res) => {
    try {
        const { testIds, newStatus } = req.body;

        if (!testIds || !Array.isArray(testIds) || testIds.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'Test IDs array is required'
            });
        }

        console.log(`Bulk updating ${testIds.length} tests to status: ${newStatus}`);

        await ensureWorksheetExists('Blood_Test_Data');

        // Get all data
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Blood_Test_Data!A:L',
        });

        const rows = response.data.values || [];
        const timestamp = new Date().toISOString();
        let updatedCount = 0;

        // Update rows that match the test IDs
        for (let i = 1; i < rows.length; i++) { // Skip header row
            const row = rows[i];
            if (testIds.includes(row[0])) { // Check if ID matches
                row[8] = newStatus; // Update status (column I)
                row[11] = timestamp; // Update timestamp (column L)
                updatedCount++;
            }
        }

        // Write back all data
        await sheets.spreadsheets.values.update({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Blood_Test_Data!A:L',
            valueInputOption: 'RAW',
            resource: {
                values: rows
            }
        });

        res.json({
            success: true,
            message: `Successfully updated ${updatedCount} tests`,
            updatedCount: updatedCount,
            newStatus: newStatus
        });

    } catch (error) {
        console.error('Error bulk updating tests:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to update tests',
            error: error.message
        });
    }
});

// Update individual test field
app.put('/api/blood-test/:testId', async (req, res) => {
    try {
        const { testId } = req.params;
        const { field, value } = req.body;

        console.log(`Updating test ${testId}, field: ${field}, value: ${value}`);

        await ensureWorksheetExists('Blood_Test_Data');

        // Get all data
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Blood_Test_Data!A:L',
        });

        const rows = response.data.values || [];
        const timestamp = new Date().toISOString();
        let updated = false;

        // Find and update the specific row
        for (let i = 1; i < rows.length; i++) { // Skip header row
            const row = rows[i];
            if (row[0] === testId) { // Check if ID matches
                // Map field names to column indices
                const fieldMap = {
                    'date': 1,
                    'iycNumber': 2,
                    'name': 3,
                    'category': 4,
                    'phone': 5,
                    'testName': 6,
                    'referredBy': 7,
                    'status': 8,
                    'remarks': 9
                };

                if (fieldMap[field] !== undefined) {
                    row[fieldMap[field]] = value;
                    row[11] = timestamp; // Update timestamp (column L)
                    updated = true;
                    break;
                }
            }
        }

        if (!updated) {
            return res.status(404).json({
                success: false,
                message: 'Test not found or invalid field'
            });
        }

        // Write back all data
        await sheets.spreadsheets.values.update({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Blood_Test_Data!A:L',
            valueInputOption: 'RAW',
            resource: {
                values: rows
            }
        });

        res.json({
            success: true,
            message: 'Test updated successfully',
            testId: testId,
            field: field,
            value: value
        });

    } catch (error) {
        console.error('Error updating test:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to update test',
            error: error.message
        });
    }
});

// Delete tests (bulk operation)
app.delete('/api/blood-tests', async (req, res) => {
    try {
        const { testIds } = req.body;

        if (!testIds || !Array.isArray(testIds) || testIds.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'Test IDs array is required'
            });
        }

        console.log(`Deleting ${testIds.length} tests`);

        await ensureWorksheetExists('Blood_Test_Data');

        // Get all data
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Blood_Test_Data!A:L',
        });

        const rows = response.data.values || [];
        let deletedCount = 0;

        // Filter out rows that match the test IDs
        const filteredRows = rows.filter((row, index) => {
            if (index === 0) return true; // Keep header row

            if (testIds.includes(row[0])) {
                deletedCount++;
                return false; // Remove this row
            }
            return true; // Keep this row
        });

        // Clear the worksheet and write back filtered data
        await sheets.spreadsheets.values.clear({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Blood_Test_Data!A:L'
        });

        if (filteredRows.length > 0) {
            await sheets.spreadsheets.values.update({
                spreadsheetId: SPREADSHEET_ID,
                range: 'Blood_Test_Data!A:L',
                valueInputOption: 'RAW',
                resource: {
                    values: filteredRows
                }
            });
        }

        res.json({
            success: true,
            message: `Successfully deleted ${deletedCount} tests`,
            deletedCount: deletedCount
        });

    } catch (error) {
        console.error('Error deleting tests:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to delete tests',
            error: error.message
        });
    }
});

// Debug endpoint to check worksheet data
app.get('/api/debug/worksheets', async (req, res) => {
    try {
        const response = await sheets.spreadsheets.get({
            spreadsheetId: SPREADSHEET_ID
        });

        const worksheetInfo = response.data.sheets.map(sheet => ({
            title: sheet.properties.title,
            sheetId: sheet.properties.sheetId,
            rowCount: sheet.properties.gridProperties.rowCount,
            columnCount: sheet.properties.gridProperties.columnCount
        }));

        res.json({
            success: true,
            worksheets: worksheetInfo,
            spreadsheetId: SPREADSHEET_ID
        });

    } catch (error) {
        console.error('Error getting worksheet info:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get worksheet info',
            error: error.message
        });
    }
});

// Debug endpoint to check specific worksheet data
app.get('/api/debug/worksheet/:name', async (req, res) => {
    try {
        const { name } = req.params;

        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: `${name}!A:L`,
        });

        const rows = response.data.values || [];

        res.json({
            success: true,
            worksheet: name,
            rowCount: rows.length,
            data: rows,
            headers: rows[0] || []
        });

    } catch (error) {
        console.error('Error getting worksheet data:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get worksheet data',
            error: error.message
        });
    }
});

// Serve the main HTML file
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Start server
app.listen(PORT, () => {
    console.log(`ðŸš€ Clinic Management Server running on http://localhost:${PORT}`);
    console.log(`ðŸ“Š Google Sheets integration active`);
    console.log(`ðŸ“‹ Spreadsheet ID: ${SPREADSHEET_ID}`);
});

// Handle graceful shutdown
process.on('SIGINT', () => {
    console.log('\nðŸ‘‹ Shutting down server gracefully...');
    process.exit(0);
});
